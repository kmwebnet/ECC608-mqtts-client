/* This is mbedtls boilerplate for library configuration */
#if !defined(MBEDTLS_CONFIG_FILE)
#include "mbedtls/esp_config.h"
#else
#include MBEDTLS_CONFIG_FILE
#endif

/* System Includes */
#include "stdio.h"
#include "stdlib.h"
#include <string.h>


/* From mbedtls */
#include "mbedtls/platform.h"
#include "mbedtls/net_sockets.h"
#include "mbedtls/esp_debug.h"
#include "mbedtls/ssl.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/error.h"
#include "mbedtls/certs.h"
#include "mbedtls/pk.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/ecdh.h"

/* From Cryptoauthlib */
#include "cryptoauthlib.h"
#include "atcacert/atcacert_client.h"
#include "mbedtls/atca_mbedtls_wrap.h"



#include "atcacert/atcacert_def.h"


/* Local Includes */
#include "cert_chain.h"


/* ESP32 specific */
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event_loop.h"
#include "esp_system.h"
#include "nvs_flash.h"

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "mbedtls_config.h"



//for heap calculating
#include "esp_heap_caps.h"


//for debug 
#include "mbedtls/debug.h"

#include "mqtt_client.h"

#include "bme280.h"


#define SDA_PIN2 GPIO_NUM_18
#define SCL_PIN2 GPIO_NUM_19


#define TAG "ECC608"

#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1


/* The examples use simple WiFi configuration that you can set via
   'make menuconfig'.
   If you'd rather not, just change the below entries to strings with
   the config you want - ie #define EXAMPLE_WIFI_SSID "mywifissid"
*/
#define EXAMPLE_WIFI_SSID "kmwebnet"
#define EXAMPLE_WIFI_PASS "c34rAeeS"

/* FreeRTOS event group to signal when we are connected & ready to make a request */
static EventGroupHandle_t wifi_event_group;

/* The event group allows multiple bits for each event,
   but we only care about one event - are we connected
   to the AP with an IP? */
const int CONNECTED_BIT = BIT0;

const char rootcacert[]={
"-----BEGIN CERTIFICATE-----\n"
"MIIBlDCCATqgAwIBAgIQXT0snwfzfj61feriSbNeVjAKBggqhkjOPQQDAjAyMREw\n"
"DwYDVQQKDAhrbXdlYm5ldDEdMBsGA1UEAwwUanVweXRlci5rbXdlYm5ldC5jb20w\n"
"HhcNMTkwNDE5MDE1MzQ5WhcNNDQwNDE5MDE1MzQ5WjAyMREwDwYDVQQKDAhrbXdl\n"
"Ym5ldDEdMBsGA1UEAwwUanVweXRlci5rbXdlYm5ldC5jb20wWTATBgcqhkjOPQIB\n"
"BggqhkjOPQMBBwNCAARpPjntwWno+/DARg9cYdPGmcJEX1Jn7fZ7HXB/T1uom5vT\n"
"pAd3IYYnObYZJr5xook56EzeRJUMxdhbMgZxIVshozIwMDAdBgNVHQ4EFgQUKtbG\n"
"hhdHkD82EUTH0GWZLUU71skwDwYDVR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNI\n"
"ADBFAiEA1OuerIKh+u3/jL0WE92m6Za9BTUMkVFHv44qnMTmoUMCIFoY7Sgk3Sy4\n"
"GyBIzBQcFTcInk/sf8pfNz/0pA5wAE5s\n"
"-----END CERTIFICATE-----\n"
};



void i2c_master_init()
{

	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN2,
		.scl_io_num = SCL_PIN2,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 100000
		};
			
	i2c_param_config(I2C_NUM_0 , &i2c_config);
	i2c_driver_install(I2C_NUM_0 , I2C_MODE_MASTER, 0, 0, 0);


}

void get_atecc608cfg(ATCAIfaceCfg *cfg)
{
                cfg->iface_type             = ATCA_I2C_IFACE;
                cfg->devtype                = ATECC608A;
                cfg->atcai2c.slave_address  = 0XC0;
                cfg->atcai2c.bus            = 1;
                cfg->atcai2c.baud           = 100000;
                cfg->wake_delay             = 1500;
                cfg->rx_retries             = 20;

return;
}

static esp_err_t event_handler(void *ctx, system_event_t *event)
{
    switch(event->event_id) {
    case SYSTEM_EVENT_STA_START:
        esp_wifi_connect();
        break;
    case SYSTEM_EVENT_STA_GOT_IP:
        xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        /* This is a workaround as ESP32 WiFi libs don't currently
           auto-reassociate. */
        esp_wifi_connect();
        xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);
        break;
    default:
        break;
    }
    return ESP_OK;
}

static void initialise_wifi(void)
{
    tcpip_adapter_init();
    wifi_event_group = xEventGroupCreate();
    ESP_ERROR_CHECK( esp_event_loop_init(event_handler, NULL) );
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK( esp_wifi_init(&cfg) );
    ESP_ERROR_CHECK( esp_wifi_set_storage(WIFI_STORAGE_RAM) );
    wifi_config_t wifi_config = {
        .sta = {
            .ssid = EXAMPLE_WIFI_SSID,
            .password = EXAMPLE_WIFI_PASS,
        },
    };
    ESP_LOGI(TAG, "Setting WiFi configuration SSID %s...", wifi_config.sta.ssid);
    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_STA) );
    ESP_ERROR_CHECK( esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) );
    ESP_ERROR_CHECK( esp_wifi_start() );
}



  s8 BME280_I2C_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
  {
    s32 iError = BME280_INIT_VALUE;

    esp_err_t espRc;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);

    i2c_master_write_byte(cmd, reg_addr, true);
    i2c_master_write(cmd, reg_data, cnt, true);
    i2c_master_stop(cmd);

    espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 20/portTICK_PERIOD_MS);
    if (espRc == ESP_OK) {
      iError = SUCCESS;
    } else {
      iError = FAIL;
    }
    i2c_cmd_link_delete(cmd);

    return (s8)iError;
  }

  s8 BME280_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
  {
    s32 iError = BME280_INIT_VALUE;
    esp_err_t espRc;

    i2c_cmd_handle_t cmd = i2c_cmd_link_create();

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_READ, true);

    if (cnt > 1) {
      i2c_master_read(cmd, reg_data, cnt-1, I2C_MASTER_ACK);
    }
    i2c_master_read_byte(cmd, reg_data+cnt-1, I2C_MASTER_NACK);
    i2c_master_stop(cmd);

    espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 20/portTICK_PERIOD_MS);
    if (espRc == ESP_OK) {
      iError = SUCCESS;
    } else {
      iError = FAIL;
    }

    i2c_cmd_link_delete(cmd);

    return (s8)iError;
  }

  void BME280_delay_msek(u32 msek)
  {
    vTaskDelay(msek/portTICK_PERIOD_MS);
  }






static esp_err_t mqtt_event_handler(esp_mqtt_event_handle_t event)
{
    esp_mqtt_client_handle_t client = event->client;
    int msg_id;
    // your_context_t *context = event->context;
    switch (event->event_id) {
        case MQTT_EVENT_CONNECTED:
            ESP_LOGI(TAG, "MQTT_EVENT_CONNECTED");
            msg_id = esp_mqtt_client_subscribe(client, "/topic/qos0", 0);
            ESP_LOGI(TAG, "sent subscribe successful, msg_id=%d", msg_id);

            msg_id = esp_mqtt_client_subscribe(client, "/topic/qos1", 1);
            ESP_LOGI(TAG, "sent subscribe successful, msg_id=%d", msg_id);

            msg_id = esp_mqtt_client_unsubscribe(client, "/topic/qos1");
            ESP_LOGI(TAG, "sent unsubscribe successful, msg_id=%d", msg_id);
            break;
        case MQTT_EVENT_DISCONNECTED:
            ESP_LOGI(TAG, "MQTT_EVENT_DISCONNECTED");
            break;

        case MQTT_EVENT_SUBSCRIBED:
            ESP_LOGI(TAG, "MQTT_EVENT_SUBSCRIBED, msg_id=%d", event->msg_id);
            msg_id = esp_mqtt_client_publish(client, "/topic/qos0", "data", 0, 0, 0);
            ESP_LOGI(TAG, "sent publish successful, msg_id=%d", msg_id);
            break;
        case MQTT_EVENT_UNSUBSCRIBED:
            ESP_LOGI(TAG, "MQTT_EVENT_UNSUBSCRIBED, msg_id=%d", event->msg_id);
            break;
        case MQTT_EVENT_PUBLISHED:
            ESP_LOGI(TAG, "MQTT_EVENT_PUBLISHED, msg_id=%d", event->msg_id);
            break;
        case MQTT_EVENT_DATA:
            ESP_LOGI(TAG, "MQTT_EVENT_DATA");
            printf("TOPIC=%.*s\r\n", event->topic_len, event->topic);
            printf("DATA=%.*s\r\n", event->data_len, event->data);
            break;
        case MQTT_EVENT_ERROR:
            ESP_LOGI(TAG, "MQTT_EVENT_ERROR");
            break;
    }
    return ESP_OK;
}


static void mqtt_app_start(void)
{
    const esp_mqtt_client_config_t mqtt_cfg = {
        .uri = "mqtts://iot.kmwebnet.com:8883",
//        .host = "",
//        .port = ,
        .event_handle = mqtt_event_handler,
        .cert_pem = (const char *)rootcacert,
    };

    ESP_LOGI(TAG, "[APP] Free memory: %d bytes", esp_get_free_heap_size());
    esp_mqtt_client_handle_t client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_start(client);


      struct bme280_t bme280 = {
        .bus_write = BME280_I2C_bus_write,
        .bus_read = BME280_I2C_bus_read,
        .dev_addr = BME280_I2C_ADDRESS1,
        .delay_msec = BME280_delay_msek
      };

      s32 com_rslt;
      s32 v_uncomp_pressure_s32;
      s32 v_uncomp_temperature_s32;
      s32 v_uncomp_humidity_s32;

      com_rslt = bme280_init(&bme280);

      com_rslt += bme280_set_oversamp_pressure(BME280_OVERSAMP_16X);
      com_rslt += bme280_set_oversamp_temperature(BME280_OVERSAMP_2X);
      com_rslt += bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);
      com_rslt += bme280_set_standby_durn(BME280_STANDBY_TIME_1_MS);
      com_rslt += bme280_set_filter(BME280_FILTER_COEFF_16);
      com_rslt += bme280_set_power_mode(BME280_NORMAL_MODE);




// MQTT Publish loop

    while(1) {


  printf("Free Heap Size 8bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_8BIT));
  printf("Free Heap Size 32bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_32BIT));


			vTaskDelay(40/portTICK_PERIOD_MS);

            com_rslt = bme280_read_uncomp_pressure_temperature_humidity(
          &v_uncomp_pressure_s32, &v_uncomp_temperature_s32, &v_uncomp_humidity_s32);

          if (com_rslt != SUCCESS) {
            
            ESP_LOGE(TAG, "measure error. code: %d", com_rslt);
          }
          ESP_LOGI(TAG, "Stack remaining for task '%s' is %d bytes", pcTaskGetTaskName(NULL), uxTaskGetStackHighWaterMark(NULL));

char pubMessage[128];

    sprintf(pubMessage, 
        "{\"Temparature\": \"%f\" , " 
        "\"Pressure\": \"%f\" , " 
        "\"Humidity\": \"%f\"}",         
        bme280_compensate_temperature_double(v_uncomp_temperature_s32),
        bme280_compensate_pressure_double(v_uncomp_pressure_s32)/100,
        bme280_compensate_humidity_double(v_uncomp_humidity_s32)) ;


esp_mqtt_client_publish(client, "/topic/qos0", pubMessage, 0, 0, 0);

const portTickType yDelay = 10000 / portTICK_RATE_MS; // 1000ms

vTaskDelay(yDelay);

    }
}


void sysinit(void)
{

        ATCAIfaceCfg cfg = {
                .iface_type             = ATCA_I2C_IFACE,
                .devtype                = ATECC608A,
                .atcai2c.slave_address  = 0XC0,
                .atcai2c.bus            = 1,
                .atcai2c.baud           = 100000,
                .wake_delay             = 1500,
                .rx_retries             = 20
        };

    ATCA_STATUS status = atcab_init(&cfg);

    if (status != ATCA_SUCCESS) {
        ESP_LOGE(TAG, "atcab_init() failed with ret=0x%08d\r\n", status);
    }
	

    uint8_t rand_out[RANDOM_NUM_SIZE];
    status = atcab_random(rand_out);

    if (status != ATCA_SUCCESS) {
        ESP_LOGE(TAG, "atcab_random() failed with ret=0x%08d\r\n", status);
    }

    uint8_t serial[ATCA_SERIAL_NUM_SIZE];
    status = atcab_read_serial_number(serial);

    if (status != ATCA_SUCCESS) {
	ESP_LOGE(TAG, "atcab_read_serial_number() failed with ret=0x%08d/r/n", status);
    }

    
    uint8_t revision[INFO_SIZE];
    status = atcab_info(revision);

    if (status != ATCA_SUCCESS) {
	ESP_LOGE(TAG, "atcab_read_serial_number() failed with ret=0x%08d/r/n", status);
    }


    uint8_t config_data[ATCA_ECC_CONFIG_SIZE];
    status = atcab_read_config_zone(config_data);

    if (status != ATCA_SUCCESS) {
	ESP_LOGE(TAG, "atcab_read_config_zone() failed with ret=0x%08d/r/n", status);
    }
	

    	printf("Random Number:\n");

    for (int i = 0; i < 4; i++){
        for(int j = 0; j < 8; j++){
	     printf("%02x ", rand_out[i * 8 + j]);
        }
	printf("\n");	
    }

	printf("Serial Number:\n");

	for ( int i =0; i< 9; i++){
	    printf("%02x ", serial[i]);
        }
	   printf("\n");

	printf("Revision Number:\n");

	for ( int i =0; i< 4; i++){
	    printf("%02x ", revision[i]);
        }
        printf("\n");	

	printf("Config Zone data:\n");

        for (int i = 0; i < 16; i++){
           for(int j = 0; j < 8; j++){
	     printf("%02x ", config_data[i * 8 + j]);
           }
	   printf("\n");
        }

  printf("Free Heap Size 8bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_8BIT));
  printf("Free Heap Size 32bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_32BIT));

}



void app_main(void)
{

    ESP_LOGI(TAG, "[APP] Startup..");
    ESP_LOGI(TAG, "[APP] Free memory: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "[APP] IDF version: %s", esp_get_idf_version());

    esp_log_level_set("*", ESP_LOG_INFO);
    esp_log_level_set("MQTT_CLIENT", ESP_LOG_VERBOSE);
    esp_log_level_set("TRANSPORT_TCP", ESP_LOG_VERBOSE);
    esp_log_level_set("TRANSPORT_SSL", ESP_LOG_VERBOSE);
    esp_log_level_set("TRANSPORT", ESP_LOG_VERBOSE);
    esp_log_level_set("OUTBOX", ESP_LOG_VERBOSE);

    printf("Free Heap Size 8bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_8BIT));
    printf("Free Heap Size 32bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_32BIT));    
	i2c_master_init();
    ESP_ERROR_CHECK( nvs_flash_init() );
    initialise_wifi();
    xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT,false, true, portMAX_DELAY);
    sysinit();
	mqtt_app_start(); 
}
